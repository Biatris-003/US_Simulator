import numpy as np
from scipy.signal import convolve2d

class UltrasoundSimulator:
    def __init__(self, grid_size=256):
        self.grid_size = grid_size
        
        # Physical dimensions
        self.width_m = 40e-3   # 40mm wide
        self.depth_m = 60e-3   # 60mm deep
        
        # Coordinate system
        self.x = np.linspace(-self.width_m/2, self.width_m/2, grid_size)
        self.z = np.linspace(0, self.depth_m, grid_size)
        self.X, self.Z = np.meshgrid(self.x, self.z)
        
        # Storage for images
        self.fundamental_img = None
        self.harmonic_img = None
        self.phantom = None
        self.cyst_masks = []
        
        # Target location for metrics
        self.wire_depth_m = 25e-3

    def create_phantom(self, num_cysts=3):
        """Generates the tissue map (Scatterers + Cysts + Wires)"""
        np.random.seed(42) # Fixed seed so phantom doesn't dance around
        
        # 1. Background Tissue (Speckle)
        self.phantom = np.abs(np.random.normal(0, 1, (self.grid_size, self.grid_size)))
        
        # 2. Cysts (Black holes)
        configs = [
            (0, 30e-3, 6e-3),       # Center Large
            (-12e-3, 45e-3, 4e-3),  # Deep Left
            (12e-3, 15e-3, 3e-3),   # Shallow Right
            (-8e-3, 20e-3, 2.5e-3), 
            (8e-3, 40e-3, 3.5e-3)
        ]
        
        self.cyst_masks = []
        for cx, cz, r in configs[:num_cysts]:
            mask = (self.X - cx)**2 + (self.Z - cz)**2 < r**2
            self.phantom[mask] *= 0.05 # Reduce scatter (anechoic)
            self.cyst_masks.append(mask)

        # 3. Wire Targets (Bright dots for resolution)
        # We ensure one is exactly at our measurement depth
        wire_depths = [10e-3, self.wire_depth_m, 40e-3, 55e-3]
        for d in wire_depths:
            z_idx = np.argmin(np.abs(self.z - d))
            x_idx = np.argmin(np.abs(self.x - 0))
            # 2x2 pixel target
            self.phantom[z_idx:z_idx+2, x_idx:x_idx+2] = 50.0 
            
        return self.phantom

    def get_psf(self, mode, freq_hz, nonlinear_coeff, is_obese):
        """
        Calculates the Point Spread Function (Beam Shape).
        THIS IS WHERE THE SLIDERS CHANGE THE IMAGE.
        """
        # Kernel Grid
        k_size = 41
        xk = np.linspace(-6, 6, k_size)
        zk = np.linspace(-3, 3, k_size)
        Xk, Zk = np.meshgrid(xk, zk)
        
        # 1. Frequency Effect: Higher Freq = Narrower Beam
        # We normalize to 3.5MHz. If freq > 3.5, beam gets smaller.
        freq_scale = (3.5e6 / freq_hz) 
        
        r = np.sqrt(Xk**2)
        
        if mode == 'fundamental':
            # --- Fundamental Physics ---
            
            # Beam Width logic
            width_factor = 0.8
            # If Obese, the beam smears (aberration)
            if is_obese: width_factor = 0.4 
            
            # Sinc function (Main Beam)
            main_lobe = np.sinc(r / (width_factor * freq_scale))
            
            # Side Lobes logic
            sl_amp = 0.2
            # If Obese, side lobes are huge (foggy image)
            if is_obese: sl_amp = 0.5
            
            side_lobes = sl_amp * np.exp(-(r - 3)**2) * np.cos(2*np.pi*r)
            beam = main_lobe + side_lobes
            
        else:
            # --- Harmonic Physics ---
            # Harmonics are generated by Fundamental^2.
            # They bypass body wall aberration (Fat).
            
            # Base width stays tight even in obese patients
            base_width = 0.8 if not is_obese else 0.75
            
            base = np.sinc(r / (base_width * freq_scale))
            # Add some base side lobes to suppress
            base += 0.15 * np.exp(-(r - 3)**2) * np.cos(2*np.pi*r)
            
            # THE MAGIC: Square the beam (Nonlinear generation)
            beam = base ** 2
            
            # Intensity depends on Nonlinear Coefficient
            beam = beam * (nonlinear_coeff * 5.0)
            
            # Obese just attenuates signal, doesn't blur it much
            if is_obese: beam *= 0.7

        # Axial Pulse (Depth)
        pulse = np.exp(-Zk**2 / (0.8 * freq_scale)) * np.cos(2*np.pi*Zk)
        
        return beam * pulse

    def run_imaging(self, mode, freq_hz, nonlinear_coeff, pulse_inv, is_obese):
        """Convolves Phantom with PSF to make the image."""
        
        # 1. Get the beam shape for current sliders
        psf = self.get_psf(mode, freq_hz, nonlinear_coeff, is_obese)
        
        # 2. Convolve (The Scanning Process)
        rf = convolve2d(self.phantom, psf, mode='same')
        envelope = np.abs(rf)
        
        # 3. Pulse Inversion Logic
        # If Harmonic mode AND PI is OFF, add fundamental noise
        if mode == 'harmonic' and not pulse_inv:
            fund_psf = self.get_psf('fundamental', freq_hz, nonlinear_coeff, is_obese)
            leakage = convolve2d(self.phantom, fund_psf, mode='same')
            
            leak_amount = 0.25 if not is_obese else 0.45
            envelope += leak_amount * np.abs(leakage)
            
        # 4. Log Compression (dB)
        envelope = envelope / (np.max(envelope) + 1e-9)
        img_db = 20 * np.log10(envelope + 1e-5)
        img_db = np.clip(img_db, -60, 0)
        
        # Store result
        if mode == 'fundamental':
            self.fundamental_img = img_db
        else:
            self.harmonic_img = img_db
            
        return img_db

    def get_profiles(self, freq_hz, nonlinear_coeff, is_obese):
        """Calculates the 1D depth curves."""
        z = np.linspace(0, 6, 100)
        f_MHz = freq_hz / 1e6
        
        alpha = 0.5 if not is_obese else 0.9 # Attenuation
        
        # Fund: Decay
        fund = np.exp(-(2 * alpha * f_MHz * z) / 8.686)
        if np.max(fund) > 0: fund /= np.max(fund)
        
        # Harm: Grow + Decay
        # Growth depends on Nonlinear Coeff
        growth = (nonlinear_coeff * 4.0) * z
        decay = np.exp(-(2 * alpha * (2*f_MHz) * z) / 8.686)
        harm = growth * decay
        
        # Scale for visibility
        harm_scale = 1.2 if not is_obese else 0.9
        harm = harm * (1.0 + nonlinear_coeff) * harm_scale
        
        return z, fund, harm

    def get_metrics(self):
        """Robust metric calculation finding the wire automatically."""
        metrics = {}
        
        # Find expected wire location
        center_x = self.grid_size // 2
        exp_z = int((self.wire_depth_m / self.depth_m) * self.grid_size)
        
        def analyze(img):
            # Find exact peak near expected depth
            search = img[exp_z-5:exp_z+5, center_x]
            offset = np.argmax(search)
            true_z = (exp_z - 5) + offset
            
            # Get Lateral Profile
            row = 10**(img[true_z, :]/20)
            row /= np.max(row)
            
            # FWHM
            above = np.where(row >= 0.5)[0]
            if len(above) > 0:
                width = (above[-1] - above[0]) * ((self.width_m*1000)/self.grid_size)
                if width == 0: width = (self.width_m*1000)/self.grid_size
            else: width = 0
            
            # Side Lobe (look >12 px away)
            mask = np.ones(self.grid_size, dtype=bool)
            mask[center_x-12:center_x+12] = False
            sidelobe = np.max(img[true_z, mask])
            if sidelobe < -55: sidelobe = -60
            
            return width, sidelobe

        f_res, f_sl = analyze(self.fundamental_img)
        h_res, h_sl = analyze(self.harmonic_img)
        
        metrics['fund_fwhm_mm'] = f_res
        metrics['harm_fwhm_mm'] = h_res
        metrics['fund_sidelobe_db'] = f_sl
        metrics['harm_sidelobe_db'] = h_sl
        
        # CNR
        if self.cyst_masks:
            mask = self.cyst_masks[0]
            def cnr(img):
                lin = 10**(img/20)
                mu_c, mu_b = np.mean(lin[mask]), np.mean(lin[~mask])
                std_c, std_b = np.std(lin[mask]), np.std(lin[~mask])
                if (std_c**2 + std_b**2) < 1e-9: return 0
                return np.abs(mu_c - mu_b)/np.sqrt(std_c**2 + std_b**2)
            
            metrics['fund_cnr'] = cnr(self.fundamental_img)
            metrics['harm_cnr'] = cnr(self.harmonic_img)
            
        return metrics